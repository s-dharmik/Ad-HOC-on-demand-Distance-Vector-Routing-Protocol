#include "contiki.h"
#include "random.h"
#include "net/rime/rime.h"
#include "dev/leds.h"
#include "dev/button-sensor.h"
#include "aodv1.h"
#include <stdio.h>


#define MAX_NODES 8 // Maximum Number of Nodes


#define BROADCAST_CHANNEL 26
#define RREP_CHANNEL 22
#define RREQ_CHANNEL BROADCAST_CHANNEL  //Don't modify!


// For Callbacks
static void route_reply_callback(struct unicast_conn *, const linkaddr_t *);
static void route_request_callback(struct broadcast_conn *, const linkaddr_t *);

// Other helper functions
static void print_rreq_routing_cache(int node);
static void print_rrep_routing_cache(int node);
static int find_next_node(int node);

PROCESS(initializer, " Initializes Connections");
PROCESS(rreq_handler, "for Handling all route Requests");
PROCESS(rrep_handler, "for Handling all route Replies");


AUTOSTART_PROCESSES(&initializer,
                    &rreq_handler,
                    &rrep_handler);
                    
// variables for Connections
static struct unicast_conn rrep_conn;
static struct broadcast_conn rreq_conn;

// variables for Callbacks
static const struct unicast_callbacks rrep_callback = {route_reply_callback};
static const struct broadcast_callbacks rreq_callback = {route_request_callback};

// variables for route_caches
static struct ROUTE_CACHE rreq_rc[MAX_NODES];
static struct ROUTE_CACHE rrep_rc[MAX_NODES];

PROCESS_THREAD(initializer, ev, data)
{
    // Stop all communications
    PROCESS_EXITHANDLER(
        {
            unicast_close(&rrep_conn);
            broadcast_close(&rreq_conn);
        });

    PROCESS_BEGIN();

    unicast_open(&rrep_conn, RREP_CHANNEL, &rrep_callback);

    broadcast_open(&rreq_conn, RREQ_CHANNEL, &rreq_callback);

    printf("Node Initialized.\n");
    PROCESS_END();
}


PROCESS_THREAD(rreq_handler, ev, data)
{
    static struct RREQ rreq_pkt;
    static struct etimer et_req;
    static int dest;
    printf("This is node --> %d", linkaddr_node_addr.u8[0]);
    printf("\n");
    PROCESS_BEGIN();
    while (1)
    {
      SENSORS_ACTIVATE(button_sensor);
      PROCESS_WAIT_EVENT();
    	//in the case of data_handler timer, ex, Data needs to be generated.
      if (ev == sensors_event && data == &button_sensor)
      {
          printf("Received button event, now generating request from initial node...\n");
          dest = 1 + random_rand() % MAX_NODES;
          if(dest==linkaddr_node_addr.u8[0])
              dest = (dest!=MAX_NODES)? dest+1 : 1;
          rreq_pkt.destId = dest;
          rreq_pkt.srcId = linkaddr_node_addr.u8[0];
          rreq_pkt.seqNo = 1;
          rreq_pkt.hops = 0;
          strcpy(rreq_pkt.payload, "It's a secret message!!!");
    	    packetbuf_clear();
    	    packetbuf_copyfrom(&rreq_pkt, sizeof(rreq));
    	    broadcast_send(&rreq_conn);
          printf("Broadcasting packet sent from initial node...\n");
     	    etimer_set(&et_req, CLOCK_SECOND);
    	    PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&et_req));
    	}

      // in the case of event is generated by the data message Callback, i.e. forwarding of Packet
      if(ev == PROCESS_EVENT_MSG)
      {
          printf("This is not a source or destination, so need to forward this packet...\n");
          rreq_pkt.destId = ((rreq *)data)->destId;
          rreq_pkt.srcId = ((rreq *)data)->srcId;
          rreq_pkt.hops = ((rreq *)data)->hops;
          rreq_pkt.seqNo = ((rreq *)data)->seqNo + 1;
          strcpy(rreq_pkt.payload, ((rreq *)data)->payload);
    	    packetbuf_clear();
    	    packetbuf_copyfrom(&rreq_pkt, sizeof(rreq));
    	    broadcast_send(&rreq_conn);
          printf("Broadcasted packet forwarded successfully!! \n");
    	    etimer_set(&et_req, CLOCK_SECOND);
    	    PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&et_req));
	     }
    }
    PROCESS_END();
}


PROCESS_THREAD(rrep_handler, ev, data)
{
    static struct RREP rrep_pkt;
    static struct etimer et_rep;
    printf("Right now in Route Reply Handler and This is a node: %d",linkaddr_node_addr.u8[0]);
    printf("\n");
    PROCESS_BEGIN();
    PROCESS_WAIT_EVENT();
    // in the case of  event is generated by data message Callback, i.e. forwarding data package
    if(ev == PROCESS_EVENT_MSG)
    {
        printf("Forwarding reply...\n");
        rrep_pkt.destId = ((rrep *)data)->destId;
        rrep_pkt.srcId = ((rrep *)data)->srcId;
        rrep_pkt.hops = ((rrep *)data)->hops;
        rrep_pkt.seqNo = ((rrep *)data)->seqNo;
        static linkaddr_t next;
        next.u8[0] = find_next_node(linkaddr_node_addr.u8[0]);
        packetbuf_clear();
        packetbuf_copyfrom(&rrep_pkt, sizeof(rrep));
        unicast_send(&rrep_conn, &next);
        printf("packet of route reply forwarded successfully!!! \n");
        etimer_set(&et_rep, CLOCK_SECOND);
        PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&et_rep));
   }
    PROCESS_END();
}

static void route_reply_callback(struct unicast_conn *c, const linkaddr_t *from)
{
    static struct RREP *rrep_pkt;
    rrep_pkt = (char *)packetbuf_dataptr();
    printf("This node is %d. I recieved route_reply from %d [Dest:%d, Src:%d, Hops: %d]\n",
           linkaddr_node_addr.u8[0],from->u8[0], (*rrep_pkt).destId, (*rrep_pkt).srcId,(*rrep_pkt).hops);

     //incrementing hops
     (*rrep_pkt).hops = (*rrep_pkt).hops + 1;
     printf("update route_cache for route_reply...\n");
     rrep_rc[linkaddr_node_addr.u8[0]].destId = (*rrep_pkt).srcId;
     rrep_rc[linkaddr_node_addr.u8[0]].next = from->u8[0];
     rrep_rc[linkaddr_node_addr.u8[0]].hops = (*rrep_pkt).hops;
     rrep_rc[linkaddr_node_addr.u8[0]].seqNo = (*rrep_pkt).seqNo;
     print_rrep_routing_cache(linkaddr_node_addr.u8[0]);

     // in case of destination node is current Node
     if ((*rrep_pkt).destId == linkaddr_node_addr.u8[0])
     {
          printf("\n Yay! we have achieved backward learning!!!\n");
      }
     // in case of case destination is not same as current node, if ROUTE_REP is new then forward
      else
      {
          printf("\n Recieved new route_reply, now forward! \n");
          process_post(&rrep_handler, PROCESS_EVENT_MSG,rrep_pkt);
      }
}


static void route_request_callback(struct broadcast_conn *c, const linkaddr_t *from)
{
    static struct RREQ *rreq_pkt;
    static struct RREP rrep_pkt;
    rreq_pkt = (char *)packetbuf_dataptr();
    printf("Route request received from %d [SeqNo:%d, Dest:%d, Src:%d, Msg: %s]\n",
           from->u8[0], (*rreq_pkt).seqNo, (*rreq_pkt).destId, (*rreq_pkt).srcId,(*rreq_pkt).payload);

    //check if packet sent by node is recevied back while broadcasting from neighbour node
    if((*rreq_pkt).srcId == linkaddr_node_addr.u8[0]){
	     printf("Duplicate data packet received and Discarded!!!\n");
    }
    else {
	    (*rreq_pkt).hops = (*rreq_pkt).hops + 1;
	 if(rreq_rc[linkaddr_node_addr.u8[0]].hops == 0 ||
		(rreq_rc[linkaddr_node_addr.u8[0]].destId == (*rreq_pkt).srcId && rreq_rc[linkaddr_node_addr.u8[0]].next == from->u8[0] && (*rreq_pkt).hops <= rreq_rc[linkaddr_node_addr.u8[0]].hops)){
        printf("route cache with less hops has been found, now update route_cache!!!");
		    rreq_rc[linkaddr_node_addr.u8[0]].destId = (*rreq_pkt).srcId;
	    	rreq_rc[linkaddr_node_addr.u8[0]].next = from->u8[0];
	    	rreq_rc[linkaddr_node_addr.u8[0]].hops = (*rreq_pkt).hops;
	    	print_rreq_routing_cache(linkaddr_node_addr.u8[0]);

	    if ((*rreq_pkt).destId == linkaddr_node_addr.u8[0])
	    {
		      printf("\nData is already at destination.\n");
          rrep_pkt.srcId = linkaddr_node_addr.u8[0];
          rrep_pkt.destId = (*rreq_pkt).srcId;
          rrep_pkt.seqNo = 120;
          rrep_pkt.hops = 0;
          static linkaddr_t next;
          next.u8[0]=from->u8[0];
          packetbuf_clear();
    	    packetbuf_copyfrom(&rrep_pkt, sizeof(rrep));
          unicast_send(&rrep_conn, &next);
          printf("Forwarding route_reply towards %d via %d [Dest:%d, Src:%d, Hops:%d]\n",
                      rrep_pkt.destId, from->u8[0], rrep_pkt.destId, rrep_pkt.srcId, rrep_pkt.hops);
      }
	    // in case if current node is not destination and Route_request is new then do Forward
	    else
	    {
		      printf("\n New route_requst!!! \n");
          process_post(&rreq_handler, PROCESS_EVENT_MSG,rreq_pkt);
	 }
	} else {
		printf("Route cache with less hops is already there!!!\n");
	}
 }
}

static void print_rreq_routing_cache(int node)
{
    printf("rreq routing cache for node: %d",node);
    printf("\n   {Dest:%d; Next:%d; Hops:%d; Seq:%d}",
               rreq_rc[node].destId, rreq_rc[node].next,
               rreq_rc[node].hops, rreq_rc[node].seqNo);
    printf("\n");
}
static void print_rrep_routing_cache(int node)
{
  printf("rrep routing cache for node: %d",node);
    printf("\n   {Dest:%d; Next:%d; Hops:%d; Seq:%d}",
               rrep_rc[node].destId, rrep_rc[node].next,
               rrep_rc[node].hops, rrep_rc[node].seqNo);
    printf("\n");
}
static int find_next_node(int node){
    return rreq_rc[node].next;
}
